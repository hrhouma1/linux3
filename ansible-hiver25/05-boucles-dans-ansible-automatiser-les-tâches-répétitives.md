## üìù Introduction

Dans ce chapitre, nous allons explorer l'utilisation des **boucles** dans Ansible pour automatiser des t√¢ches r√©p√©titives de mani√®re efficace. Les boucles vous permettent d'ex√©cuter une action plusieurs fois sans avoir √† r√©p√©ter manuellement le code pour chaque √©l√©ment. Cette fonctionnalit√© est particuli√®rement utile pour :

- **Cr√©er ou g√©rer plusieurs utilisateurs**.
- **D√©ployer des configurations sur plusieurs serveurs ou fichiers**.
- **Automatiser des t√¢ches sur des listes d'√©l√©ments**.

---

## üìã Table des Mati√®res

1. [√âtape Pr√©paratoire : Cr√©ation du Dossier de Travail](#etape-preparatoire)
2. [Configurer l'Inventaire Ansible](#configurer-inventaire)
3. [Partie 1 : Boucler sur une Liste](#partie1)
4. [Partie 2 : Boucler sur une Liste de Dictionnaires](#partie2)
5. [Partie 3 : Boucler sur un Dictionnaire](#partie3)
6. [Partie 4 : Boucler sur une Plage de Nombres](#partie4)
7. [Partie 5 : Boucler sur les H√¥tes de l'Inventaire](#partie5)
8. [Partie 6 : Utiliser une Pause dans une Boucle](#partie6)
9. [Conclusion](#conclusion)

---

<a name="etape-preparatoire"></a>
## üìÇ √âtape Pr√©paratoire : Cr√©ation du Dossier de Travail

1. **Cr√©er un dossier pour le projet Ansible** :

   ```bash
   mkdir ansible_project_loops
   ```

   Ce dossier `ansible_project_loops` servira √† stocker tous les fichiers et playbooks n√©cessaires pour cette pratique.

2. **Naviguer dans le dossier** :

   ```bash
   cd ansible_project_loops
   ```

---

<a name="configurer-inventaire"></a>
## üóÇÔ∏è Configurer l'Inventaire Ansible

1. **Cr√©er un fichier `inventory.ini`** pour d√©finir les n≈ìuds :

   ```bash
   nano inventory.ini
   ```

2. **Ajouter les informations des n≈ìuds** :

   ```ini
   [node_containers]
   node1 ansible_host=172.20.0.2 ansible_user=root ansible_python_interpreter=/usr/bin/python3
   node2 ansible_host=172.20.0.3 ansible_user=root ansible_python_interpreter=/usr/bin/python3
   node3 ansible_host=172.20.0.4 ansible_user=root ansible_python_interpreter=/usr/bin/python3
   node4 ansible_host=172.20.0.5 ansible_user=root ansible_python_interpreter=/usr/bin/python3
   node5 ansible_host=172.20.0.6 ansible_user=root ansible_python_interpreter=/usr/bin/python3
   node6 ansible_host=172.20.0.7 ansible_user=root ansible_python_interpreter=/usr/bin/python3
   ```

   **Remarque :** L'ajout de `ansible_python_interpreter=/usr/bin/python3` permet d'√©viter les avertissements li√©s √† la d√©couverte automatique de l'interpr√©teur Python.

3. **Enregistrer et quitter l'√©diteur**.

---

<a name="partie1"></a>
## üìù Partie 1 : Boucler sur une Liste

### √âtape 1 : √âcrire un Playbook pour Afficher les √âl√©ments d'une Liste

1. **Cr√©er un fichier nomm√© `print-list.yml`** :

   ```bash
   nano print-list.yml
   ```

2. **Ajouter le contenu suivant** pour afficher une liste de nombres premiers :

   ```yaml
   ---
   - name: Afficher une Liste de Nombres Premiers
     hosts: node1
     become: yes
     vars:
       prime_numbers:
         - 2
         - 3
         - 5
         - 7
         - 11
     tasks:
       - name: Afficher les Nombres Premiers
         debug:
           msg: "Nombre premier : {{ item }}"
         loop: "{{ prime_numbers }}"
   ```

   **Explications** :

   - **`vars`** : D√©finit une variable `prime_numbers` qui est une liste de nombres premiers.
   - **`loop`** : It√®re sur chaque √©l√©ment de la liste `prime_numbers`.
   - **`{{ item }}`** : Repr√©sente l'√©l√©ment courant de la boucle.

3. **Enregistrer et quitter l'√©diteur**.

4. **Ex√©cuter le playbook** :

   ```bash
   ansible-playbook -i inventory.ini print-list.yml
   ```

   **R√©sultat attendu :**

   Le playbook affichera chaque nombre premier de la liste.

---

<a name="partie2"></a>
## üìù Partie 2 : Boucler sur une Liste de Dictionnaires

### √âtape 1 : Ajouter Plusieurs Utilisateurs avec une Boucle

1. **Cr√©er un fichier `add-users.yml`** pour ajouter plusieurs utilisateurs avec des mots de passe :

   ```bash
   nano add-users.yml
   ```

2. **Ajouter le contenu suivant** :

   ```yaml
   ---
   - name: Ajouter Plusieurs Utilisateurs
     hosts: database
     become: yes
     vars:
       db_users:
         - username: "alice"
           password: "password1"
           uid: 1001
         - username: "bob"
           password: "password2"
           uid: 1002
         - username: "charlie"
           password: "password3"
           uid: 1003
     tasks:
       - name: Cr√©er les Utilisateurs
         user:
           name: "{{ item.username }}"
           uid: "{{ item.uid }}"
           password: "{{ item.password | password_hash('sha512') }}"
           shell: "/bin/bash"
           state: present
         loop: "{{ db_users }}"
   ```

   **Explications** :

   - **`db_users`** : Liste de dictionnaires, chaque dictionnaire contenant les informations d'un utilisateur.
   - **Module `user`** : Utilis√© pour g√©rer les comptes utilisateurs sur les h√¥tes cibles.
   - **`password_hash('sha512')`** : Hash le mot de passe en utilisant l'algorithme SHA-512 pour la s√©curit√©.
   - **`loop: "{{ db_users }}"`** : It√®re sur chaque utilisateur dans la liste `db_users`.




3. **Enregistrer et quitter l'√©diteur**.

4. **Ex√©cuter le playbook** :

   ```bash
   ansible-playbook -i inventory.ini add-users.yml
   ```

5. **V√©rification** :

   Utilisez la commande suivante pour confirmer que les utilisateurs ont √©t√© ajout√©s :

   ```bash
   ansible database -m command -a "getent passwd alice bob charlie" -i inventory.ini
   ```

   **Remarque :** La commande `getent passwd` affiche les entr√©es des utilisateurs sp√©cifi√©s.




**‚ùå Erreur d√©tect√©e ? Pas de panique, analysez le message d'erreur et appliquez la correction adapt√©e.**  

L'erreur provient de l'utilisation de `password_hash('sha512')` pour le hashage du mot de passe. Ansible ne parvient pas √† g√©n√©rer correctement un hash avec cette m√©thode, ce qui emp√™che la cr√©ation des utilisateurs.

## üîç **Solution 1 : Retirer `password_hash('sha512')`**
Une premi√®re solution consiste √† retirer `| password_hash('sha512')` dans la ligne du mot de passe :

### ‚úÖ **Playbook corrig√© : Suppression du hashage**
```yaml
---
- name: Ajouter Plusieurs Utilisateurs
  hosts: database
  become: yes
  vars:
    db_users:
      - username: "alice"
        password: "password1"
        uid: 1001
      - username: "bob"
        password: "password2"
        uid: 1002
      - username: "charlie"
        password: "password3"
        uid: 1003
  tasks:
    - name: Cr√©er les Utilisateurs
      user:
        name: "{{ item.username }}"
        uid: "{{ item.uid }}"
        password: "{{ item.password }}"
        shell: "/bin/bash"
        state: present
      loop: "{{ db_users }}"
```


## ‚úÖ **Ex√©cuter et V√©rifier**
Une fois le playbook mis √† jour, ex√©cutez les commandes suivantes :

```bash
ansible-playbook -i inventory.ini add-users.yml
ansible database -m command -a "getent passwd alice bob charlie" -i inventory.ini
```

‚ö†Ô∏è **Probl√®me avec cette solution** :  
Le mot de passe est stock√© en clair dans `/etc/shadow`, ce qui pose un risque de s√©curit√©. Il est recommand√© d'utiliser un mot de passe chiffr√©.

---

## üîç **Solution 2 : G√©n√©rer un Hash S√©curis√©**
Une meilleure approche consiste √† utiliser la m√©thode password_hash('sha512', secure_salt) 

Le playbook Ansible ci-dessous montre comment :
1. **G√©n√®re un sel s√©curis√©** pour le hachage des mots de passe.
2. **V√©rifie si l'UID est d√©j√† utilis√©** avant de cr√©er un utilisateur.
3. **Cr√©e des utilisateurs** en √©vitant les conflits d'UID.


### ‚úÖ **Playbook Complet de la solution 2**
```yaml
- name: G√©n√©rer des utilisateurs avec des mots de passe hash√©s
  hosts: all
  tasks:
    - name: G√©n√©rer un sel s√©curis√©
      ansible.builtin.set_fact:
        secure_salt: "{{ lookup('password', '/dev/null chars=ascii_letters,digits length=16') }}"

    - name: V√©rifier si l'UID existe d√©j√† sur le syst√®me
      shell: "id -u {{ item.uid }} || echo 'not found'"
      register: uid_check
      changed_when: false
      failed_when: false
      loop:
        - { username: "alice1", uid: 1001 }
        - { username: "bob1", uid: 1002 }
        - { username: "charlie1", uid: 1003 }

    - name: Afficher les UID existants
      debug:
        msg: "UID {{ item.item.uid }} d√©j√† utilis√© : {{ item.stdout }}"
      loop: "{{ uid_check.results }}"
      when: item.stdout is not search('not found')

    - name: Cr√©er des utilisateurs avec des mots de passe hash√©s
      ansible.builtin.user:
        name: "{{ item.username }}"
        password: "{{ item.password }}"
        uid: "{{ item.uid }}"
      loop: 
        - { username: "alice1", password: "{{ 'password1' | password_hash('sha512', secure_salt) }}", uid: 1001 }
        - { username: "bob1", password: "{{ 'password2' | password_hash('sha512', secure_salt) }}", uid: 1002 }
        - { username: "charlie1", password: "{{ 'password3' | password_hash('sha512', secure_salt) }}", uid: 1003 }
      when: 
        - "item.uid not in uid_check.results | map(attribute='stdout') | list"
```

---

###  **Explication**
1. **G√©n√©ration d'un sel s√©curis√©** (`set_fact`)  
   - Un sel al√©atoire est g√©n√©r√© pour le hachage des mots de passe.

2. **V√©rification des UID existants** (`shell: id -u ...`)  
   - V√©rifie si chaque UID est d√©j√† utilis√©.
   - Stocke le r√©sultat dans `uid_check`.

3. **Affichage des UID en conflit** (`debug`)  
   - Affiche une alerte si un UID est d√©j√† pris.

4. **Cr√©ation des utilisateurs** (`ansible.builtin.user`)  
   - Cr√©e les utilisateurs **seulement si leur UID n'existe pas d√©j√†** (`when: item.uid not in uid_check.results`).

---

### ‚úÖ **Avantages**
‚úî **√âvite les conflits d'UID** en **v√©rifiant avant de cr√©er** les utilisateurs.  
‚úî **Utilisation s√©curis√©e des mots de passe** gr√¢ce √† `password_hash`.  
‚úî **Meilleure gestion des erreurs** avec des messages explicites.  

---

### **Recommandation**
Pour √©viter **tout conflit d'UID** (si celui-ci est d√©j√† cr√©√©), utilisez le playbook ci-dessous qui r√©alise ces op√©rations: 

‚úÖ V√©rifie si un UID est d√©j√† utilis√©
‚úÖ G√©n√®re dynamiquement un nouvel UID si le pr√©c√©dent est pris
‚úÖ Cr√©e les utilisateurs avec un mot de passe s√©curis√©



Voici le **playbook Ansible am√©lior√©** qui :  
‚úÖ **V√©rifie si un UID est d√©j√† utilis√©**  
‚úÖ **G√©n√®re dynamiquement un nouvel UID** si le pr√©c√©dent est pris  
‚úÖ **Cr√©e les utilisateurs avec un mot de passe s√©curis√©**

---

### ‚úÖ **Playbook Final : UID Dynamique en Cas de Conflit**
```yaml
- name: G√©n√©rer des utilisateurs avec des mots de passe hash√©s
  hosts: all
  tasks:
    - name: G√©n√©rer un sel s√©curis√©
      ansible.builtin.set_fact:
        secure_salt: "{{ lookup('password', '/dev/null chars=ascii_letters,digits length=16') }}"

    - name: V√©rifier si l'UID existe d√©j√† sur le syst√®me
      shell: "id -u {{ item.uid }} || echo 'not found'"
      register: uid_check
      changed_when: false
      failed_when: false
      loop:
        - { username: "alice1", uid: 1001 }
        - { username: "bob1", uid: 1002 }
        - { username: "charlie1", uid: 1003 }

    - name: G√©n√©rer un UID unique si n√©cessaire
      shell: "shuf -i 2000-65000 -n 1"
      register: unique_uid
      when: item.stdout is not search('not found')
      loop: "{{ uid_check.results }}"
    
    - name: Associer les UID dynamiques aux utilisateurs
      set_fact:
        user_list: >-
          [{% for item in uid_check.results %}
            {
              "username": "{{ item.item.username }}",
              "password": "{{ ('password' ~ loop.index) | password_hash('sha512', secure_salt) }}",
              "uid": "{{ unique_uid.results[loop.index0].stdout if item.stdout is not search('not found') else item.item.uid }}"
            }
            {% if not loop.last %},{% endif %}
          {% endfor %}
          ]
      loop: "{{ uid_check.results }}"
      loop_control:
        extended: true

    - name: Cr√©er des utilisateurs avec UID dynamiques si n√©cessaire
      ansible.builtin.user:
        name: "{{ item.username }}"
        password: "{{ item.password }}"
        uid: "{{ item.uid }}"
      loop: "{{ user_list }}"
```

---

### **Explication**
1. **V√©rification des UID existants**  
   - `shell: id -u {{ item.uid }} || echo 'not found'`  
   - Stocke les r√©sultats dans `uid_check`.

2. **G√©n√©ration d'un UID unique si n√©cessaire**  
   - Si l'UID est d√©j√† pris (`not found` absent), un nouvel **UID al√©atoire** entre `2000-65000` est g√©n√©r√© via `shuf`.

3. **Cr√©ation d'une liste avec les UID corrig√©s**  
   - On **remplace l'UID existant** par un **UID al√©atoire** si n√©cessaire.
   - `user_list` est une nouvelle liste d'utilisateurs avec **UID corrig√©s**.

4. **Cr√©ation des utilisateurs**  
   - `ansible.builtin.user` cr√©e les utilisateurs avec leurs **UID mis √† jour**.

---

### ‚úÖ **Avantages**
‚úî **Emp√™che tout conflit d'UID**  
‚úî **G√©n√®re un UID unique dynamiquement si n√©cessaire**  
‚úî **Utilise des mots de passe s√©curis√©s avec un sel dynamique**  

---

###  **Recommandation**
- üí° Si vous ne voulez **aucun probl√®me d‚ÄôUID** et que l'UID statique **n‚Äôest pas obligatoire**, vous pouvez aussi supprimer `uid` du `ansible.builtin.user` et laisser le syst√®me g√©rer.
- üí° Avec ce playbook, les utilisateurs sont cr√©√©s proprement avec un UID garanti unique !



---

## üîç **Solution 3 : G√©n√©ration du Hash √† l‚ÄôEx√©cution**  
Une approche alternative consiste √† g√©n√©rer les mots de passe hash√©s avant d‚Äôex√©cuter le playbook en utilisant `mkpasswd`. Cette m√©thode permet d'√©viter de stocker les mots de passe en clair dans les fichiers Ansible.  
*(Cette solution d√©passe le cadre de ce cours.)*

## üîç **Solution 4 : Pratique 8 ‚Äì Approche de R√©solution de Probl√®mes**  
Une autre approche consiste √† explorer la **pratique 8**, qui vous aidera √† vous familiariser avec des strat√©gies efficaces pour r√©soudre ce type de probl√®me.

---

## üöÄ **Conclusion**  
- ‚úÖ **Solution 1** : Supprimer `password_hash` fonctionne, mais ce n'est pas s√©curis√©.  
- ‚úÖ **Solution 2** : Utiliser `password_hash` avec un sel est une approche plus s√©curis√©e.  
- ‚úÖ **Solution 3** : G√©n√©rer les mots de passe avec `mkpasswd` permet d‚Äô√©viter de stocker des donn√©es sensibles en clair (*hors du p√©rim√®tre de ce cours*).  
- ‚úÖ **Solution 4** : Consultez la **pratique 8** pour approfondir vos comp√©tences en r√©solution de probl√®mes.

üí° **Recommandation** : Utilisez `mkpasswd` pour g√©n√©rer des mots de passe s√©curis√©s et **ne stockez jamais de mots de passe en clair** dans vos fichiers Ansible.



---

<a name="partie3"></a>
## üìù Partie 3 : Boucler sur un Dictionnaire

Ansible ne peut pas boucler directement sur un dictionnaire. Il faut le transformer en une liste de paires cl√©/valeur en utilisant le filtre `dict2items`.

### √âtape 1 : Afficher les Paires Cl√©/Valeur d'un Dictionnaire

1. **Cr√©er un fichier nomm√© `print-dictionary.yml`** :

   ```bash
   nano print-dictionary.yml
   ```

2. **Ajouter le contenu suivant** :

   ```yaml
   ---
   - name: Afficher les Informations d'un Employ√©
     hosts: node1
     become: yes
     vars:
       employee:
         name: "Alice"
         title: "Administratrice Syst√®me"
         company: "TechCorp"
     tasks:
       - name: Afficher le Dictionnaire Employ√©
         debug:
           msg: "{{ item.key }}: {{ item.value }}"
         loop: "{{ employee | dict2items }}"
   ```

   **Explications** :

   - **`employee`** : Un dictionnaire contenant des informations sur un employ√©.
   - **`dict2items`** : Convertit le dictionnaire en une liste de paires cl√©/valeur.
   - **`{{ item.key }}` et `{{ item.value }}`** : Repr√©sentent respectivement la cl√© et la valeur de chaque √©l√©ment.

3. **Enregistrer et quitter l'√©diteur**.

4. **Ex√©cuter le playbook** :

   ```bash
   ansible-playbook -i inventory.ini print-dictionary.yml
   ```

   **R√©sultat attendu :**

   Le playbook affichera chaque attribut de l'employ√©, par exemple :

   ```
   name: Alice
   title: Administratrice Syst√®me
   company: TechCorp
   ```

---

<a name="partie4"></a>
## üìù Partie 4 : Boucler sur une Plage de Nombres

### √âtape 1 : Afficher une Plage de Nombres

1. **Cr√©er un fichier `range-loop.yml`** :

   ```bash
   nano range-loop.yml
   ```

2. **Ajouter le contenu suivant** :

   ```yaml
   ---
   - name: Boucler sur une Plage de Nombres
     hosts: node1
     become: yes
     tasks:
       - name: Afficher les Nombres de 5 √† 14
         debug:
           msg: "Nombre : {{ item }}"
         loop: "{{ range(5, 15) | list }}"
   ```

   **Explications** :

   - **`range(5, 15)`** : G√©n√®re un it√©rable de nombres de 5 √† 14 (15 est exclu).
   - **`| list`** : Convertit l'it√©rable en une liste.

3. **Enregistrer et quitter l'√©diteur**.

4. **Ex√©cuter le playbook** :

   ```bash
   ansible-playbook -i inventory.ini range-loop.yml
   ```

   **R√©sultat attendu :**

   Le playbook affichera les nombres de 5 √† 14.

---

<a name="partie5"></a>
## üìù Partie 5 : Boucler sur les H√¥tes de l'Inventaire

### √âtape 1 : Ex√©cuter une T√¢che sur Tous les N≈ìuds de l'Inventaire

1. **Cr√©er un fichier `loop-inventory.yml`** :

   ```bash
   nano loop-inventory.yml
   ```

2. **Ajouter le contenu suivant** :

   ```yaml
   ---
   - name: Boucler sur les H√¥tes de l'Inventaire
     hosts: node1
     become: yes
     tasks:
       - name: V√©rifier la Connectivit√© avec Tous les H√¥tes
         ping:
           data: "Ping depuis node1"
         delegate_to: "{{ item }}"
         loop: "{{ groups['all'] }}"
   ```

   **Explications** :

   - **`groups['all']`** : Contient tous les h√¥tes d√©finis dans l'inventaire.
   - **`delegate_to: "{{ item }}"`** : Ex√©cute la t√¢che sur l'h√¥te sp√©cifi√© par `item` au lieu du n≈ìud cible (`node1`).
   - **Module `ping`** : V√©rifie la connectivit√© Ansible entre les h√¥tes.

3. **Enregistrer et quitter l'√©diteur**.

4. **Ex√©cuter le playbook** :

   ```bash
   ansible-playbook -i inventory.ini loop-inventory.yml
   ```

   **R√©sultat attendu :**

   Le playbook testera la connectivit√© avec chaque h√¥te de l'inventaire depuis `node1`.

---

<a name="partie6"></a>
## üìù Partie 6 : Utiliser une Pause dans une Boucle

### √âtape 1 : Cr√©er un Compte √† Rebours avec une Pause

1. **Cr√©er un fichier `countdown.yml`** :

   ```bash
   nano countdown.yml
   ```

2. **Ajouter le contenu suivant** :

   ```yaml
   ---
   - name: Compte √† Rebours de 10 Secondes
     hosts: node1
     become: yes
     tasks:
       - name: Afficher le Compte √† Rebours
         debug:
           msg: "{{ item }} secondes restantes..."
         loop: "{{ range(10, 0, -1) | list }}"
         loop_control:
           delay: 1
       - name: Afficher le Message Final
         debug:
           msg: "C'est l'heure !"
   ```

   **Explications** :

   - **`range(10, 0, -1)`** : G√©n√®re une liste de nombres de 10 √† 1 en d√©cr√©mentant de 1.
   - **`loop_control: delay: 1`** : Ins√®re une pause de 1 seconde entre chaque it√©ration de la boucle.
   - **`{{ item }}`** : Repr√©sente le nombre de secondes restantes.

3. **Enregistrer et quitter l'√©diteur**.

4. **Ex√©cuter le playbook** :

   ```bash
   ansible-playbook -i inventory.ini countdown.yml
   ```

   **R√©sultat attendu :**

   Le playbook affichera un compte √† rebours de 10 √† 1 avec une pause d'une seconde entre chaque nombre, puis affichera "C'est l'heure !".

---

<a name="conclusion"></a>
## üéØ Conclusion

Dans ce chapitre, vous avez appris √† :

- **Utiliser les boucles simples avec `loop`** pour it√©rer sur des listes.
- **Boucler sur des listes de dictionnaires** pour effectuer des t√¢ches complexes comme la cr√©ation d'utilisateurs.
- **Transformer et boucler sur des dictionnaires** en utilisant le filtre `dict2items`.
- **Utiliser des plages de nombres** avec `range()` pour g√©n√©rer des s√©quences num√©riques.
- **Boucler sur les h√¥tes de l'inventaire** pour effectuer des actions sur plusieurs n≈ìuds.
- **Introduire des pauses dans les boucles** avec `loop_control` pour contr√¥ler le timing des t√¢ches.

Ces techniques vous permettent de rendre vos playbooks plus dynamiques et efficaces, en automatisant des t√¢ches r√©p√©titives sans r√©p√©ter le code.

---

<a name="conseils-supplementaires"></a>
## üõ†Ô∏è Conseils Suppl√©mentaires

- **Filtres Jinja2** : Explorez d'autres filtres comme `items2dict`, `map`, et `select` pour manipuler vos donn√©es.
- **Boucles avec `with_items`** : Bien que `loop` soit recommand√©, vous pouvez rencontrer `with_items` dans des playbooks plus anciens.
- **Contr√¥le des Boucles** : Utilisez `loop_control` pour acc√©der √† des variables sp√©ciales comme `index`, `index0`, `first`, `last`.
- **Gestion des √âchecs dans les Boucles** : Pour continuer l'ex√©cution en cas d'erreur sur un √©l√©ment, utilisez `ignore_errors` ou `failed_when`.

---

<a name="ressources-utiles"></a>
## üìö Ressources Utiles

- [Documentation Ansible - Looping Over Items](https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html)
- [Ansible Loop Control](https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html#loop-control)
- [Jinja2 Template Designer Documentation](https://jinja.palletsprojects.com/en/3.0.x/templates/)

---

<a name="conclusion"></a>
## üôå F√©licitations !

Vous avez am√©lior√© vos comp√©tences en Ansible en apprenant √† utiliser les boucles pour automatiser des t√¢ches r√©p√©titives. Continuez √† explorer ces fonctionnalit√©s pour rendre vos playbooks encore plus puissants et efficaces.


